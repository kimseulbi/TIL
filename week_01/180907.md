# 9/7 (금)

## 1. Today I learend

> Web cafe 웹페이지제작 실습 및 css 속성, html 마크업 설계 학습

### 1-1. Basic box model

![basic_box_model](../asset/basic_box_model.PNG)

문서에서 각 요소는 사각형 박스로 나타낸다. 요소에 의해 차지되는 공간의 내용(content)을 설명한다.

- margin : border 를 기준으로 다른 요소와의 바깥쪽 여백 지정
- border : 요소 박스 테두리 지정(마진과 패딩 사이)
- padding : content 영역과 border 사이의 안쪽 여백 지정
- content : 요소의 콘텐츠가 표시되는 영역

✏️ `margin: 0 auto`의 본래 의미는 가운데 정렬이 아니라 뷰포트의 나머지 영역을 투명한 영역이 다 차지하고 있는 것이다. 그 다음 요소가 옆으로 올 수 없어 요소가 가운데로 정렬된 것처럼 보이기 때문에 쓰고 있다.

- [CSS 박스 모델 입문 - MDN](https://goo.gl/7orK89)

#### 1-1-1. box-sizing

요소의 너비와 높이를 계산하는 데 사용되는 기본적인 CSS Box Model 을 대체하기 위해 사용된다. 요소 박스의 크기를 결정하는 방식을 지정

- content-box : CSS 표준에 정의된 기본 스타일 , width와 height 속성은 오로지 콘텐츠만을 포함하여 측정되며, padding, border, margin을 포함하지 않는다.

- border-box : width 와 height 속성이 padding 및 border를 포함하며, margin을 포함하지 않는다.

box-sizing 을 베이직 박스 모델인 `content-box`가 아니라 `border-box`로 설정하면 기존에 div 2 개로 랩핑해야 가능했던 여백(padding) 디자인이 하나의 div 로도 가능하게 되어 모바일형태의 웹페이지를 제작시 좋다. 

```css
.content-box {
  box-sizing: content-box;
}
.border-box {
  box-sizing: border-box;
}
```

#### 1-1-2. overflow

내용을 잘라낼 지, 스크롤 바를 보여줄 지, 혹은 범위를 넘어가게 보여줄 지를 기술한다.

- visible : 내용이 잘리지 않음
- hidden : 내용을 자르고, 스크롤 바를 보여주지 않음
- auto : 브라우저가 결정함 

`hidden`은 내부적으로 hidden을 시키기 위해 넘치는 요소가 있는지 없는지 자식 요소의 높이를 체크하게 된다 이때 알아낸 자식요소의 높이를 반영하는데, 잃어버리는 높이를 읽어내는 듯한 효과를 얻을 수 있다.

단점은 부모영역 밖으로 넘어가는 요소들이 숨김처리되기 때문에 디자인 변화가 있을경우 대응할 수 없을 수도 있다.

` auto`나 `scroll`은 스크롤이 생기게 하기(할 수 있기) 때문에 이 역시 적절한 방법은 아니다.

```css
.main {
  overflow: hidden;
}
```

[box-sizing 관련 히스토리 CSS Trick](https://css-tricks.com/box-sizing/)

### 1-2 레이아웃 CSS

- 블록 레이아웃(block layout) : 문서 배치를 위해 설계됨. element를 float하거나 multiple columns에 걸쳐 배치하는 기술 같은 문서 중심 기능을 포함한다. 
- 인라인 레이아웃(inline layout): 텍스트 배치를 위해 설계
- 테이블 레이아웃(table layout): 표 배치를 위해 설계
- 신축 박스 레이아웃(flexible box layout): 복잡한 페이지 배치를 위해 설계 

마크업이 일반적인 흐름과 다르다면 inline-block 은 배치 기법으로 적합하지 않다.

#### 1-2-2. Flexible box model

스타일링 전 기본 배치는 위에서 아래로 선형화되어 있다. 배치를 가로방향으로 하고 싶다면 flexible 기술이 유용할 수 있다.

##### flex container

- `display: flex`: 가로방향 배치가 기본이다(`flex-driection: row`). 높이는 부모영역만큼 차지한다. flex-item 을 포함하는 flex-container 가 되며 손자 영역을 제외하고 자식영역에게만 영향을 준다.
- `flex-diection: row | row-reverse | column | column-reverse` :
  배치 방향 **메인축, 교차축이 row, column, reverse 에 따라 변경**된다.
- `flex-wrap: nowrap | wrap | wrap-reverse` : 기본적으로 자식 요소 박스가 한 줄에 맞춰 정렬되는 데 wrap 으로 지정하면 멀티라인으로 배치된다.
- `flex-flow: <flex-derection> || <flex-wrap>` : flex-direction 과 flex-wrap 의 속기법
- `justify-content: flex-start | flex-end | center | space-beteen | space-around | space-evenly`: 메인축(주축) 정렬
- `align-items: flex-start | flex-end | center | baseline | stretch` : 라인박스의 높이에 따라 배치되는 요소 박스에 배치에 영향을 주는 교차 축을 지정하는 속성, 교차축 정렬
- `align-content: flex-start | flex-end | center | baseline | stretch`: 여러개의 행이나 열로 구성된 요소 박스의 정렬을 지정

🌟 메인축 정렬과 마진의 조합으로 생기는 일

```css
.main {
  display: flex;
  flex-direction: row;
  justify-content: center; /* (메인축 가로정렬) */
}
.favorite-site {
  order: 1;
  margin: auto; /* 메인축 기준으로 왼쪽으로 밀린고 나머지 영역을 margin으로 차지한다.*/
}
```

##### flex items

- `order: <integer>` : 아이템 순서. 초기값을 0 이다. 숫자가 클 수로 뒤로 밀린다.
- `align self: align-self: auto | flex-start | flex-end | center | baseline | stretch` : 개별 요소에 적용할 수 있는 속성. align-items 가 지정된 값들을 인자로 받아 지정한 flex-items 요소에만 적용된다.
- `flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]` : flex-grow, flex-shrink, flex-basis 의 속기법. flex-shrink, flex-basic 는 선택적이다.
  - `flex-grow: <number>` : 자식요소에 확대 비율을 지정해 부모 요소의 크기에 맞게 자동으로 크기를 조정
  - `flex-shrink: <number>` : 자식요소에 축소 비율을 지정해 부모 요소의 크기에 맞게 자동으로 크기 조정
  - `flex-basis: <'width'>` : 유연하게 조절되는 박스의 기준 크기를 지정

```css
.main {
  display: flex;
}
.favorite-site {
  order: 1;
}
.twitter {
  /* default - order: 0; */
}
/* .favorite-site가 .twitter보다 먼저 마크업 되었어도 트위터 다음으로 온다. */
```

✏️ `justify-content: space-between(양 옆 거터 없음) || space-around(양 옆 거터있음);`를 쓸 때 플랙스 아이템의 넓이가 비율에 맞지 않게 크다면 비율대로 맞춰 축소해준다.( 확대 축소 알고리즘이 내장되어있다.)

- [flex froggy 예제](http://flexboxfroggy.com/#ko)
- [flex 참고링크](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)


### 1-6. float 배치

띄우다. 부유하다.

[float과 float clear](https://codepen.io/chiabi88/pen/yKzdpR)

일반적인 흐름(normal flow)을 벗어나 띄워져 부모요소를 기준으로 좌(left), 우(right)로 배치되는 기법.

float시킨 요소는 넓이를 따로 지정하지 않는 한 콘텐츠 영역만큼 줄어들어 보이지만 블록 요소이다. (flex등 일부 특수한 경우를 제외라고) 모든 요소의 성격을 블록으로 변경한다.

일반적은 흐름을 벗어난 요소는 부모 요소가 높이를 인식하지 못한다.  
float으로 띄운 요소는 다음에 오는 요소(normal flow의 요소)와 겹쳐지지만(위에 겹쳐진 것처럼 보인다.) 그 다음 요소 내부의 콘텐츠(텍스트등)는 float된 요소에 밀린다.
다음요소의 콘텐츠가 아래로 밀리면 부모요소가 높이를 인식하는 것처럼 보이지만 사실 다음 요소의 시작점은 부모요소의 시작점이다.

요소들이 모두 float되면 부모는 높이를 잃게 되는데, 부모가 높이를 잃어버렸을때 부모 요소의 형제 요소의 콘텐츠가 float된 자식요소 옆으로 붙어보이는 것은 콘텐츠는 float 요소 옆으로 흐르고, 부모의 형제요소의 시작점이 부모요소의 시작점이다.

부모 요소가 float 된 자식요소의 높이를 인식하게 하는 방법은 다음과 같은 방법들이 있다.


#### 1-6-2. 빈 엘리먼트를 추가해 clear하는 방법

부모 요소의 마지막 요소로 빈 엘리먼트(의미없는 div)를 추가해 clear하는 방법이다.  
clear 속성은 모든 부동체(float된 요소)의 마진 경계 아래로 요소의 마진 경계를 옮긴다.(내부적으로 강제 마진 알고리즘이 있다.)

```html
      <section class="favorite-site">인기사이트</section>
      <section class="twitter">트위터</section>
      <div class="clear"></div>
    </main>
```

```css
.main .section {
  float: left;
}
.clear {
  clear: both;
}
```

clear가 필요없어질 경우 의미없는 소스가 남아 지저분해 질 수도 있다.

#### 1-6-3. 부모요소의 다음에 올 형제 요소에 clear하는 방법

```html
      <section class="favorite-site">인기사이트</section>
      <section class="twitter">트위터</section>
    </main>
    <article class="slogan"></article>
```

```css
.main .section {
  float: left;
}
.slogan {
  clear: both;
}
```

float의 영향에서는 벗어나지만 부모요소는 여전히 자식요소의 높이를 인식하지 못하고 있다. 

이 방법의 경우 clear가 float된 요소만큼 마진을 내부적으로 마진을 주는 것이므로 마진이 float된 요소의 높이만큼이라 `margin-top`을 부모의 형제 요소에 지정할 경우 마진이 겹쳐 먹지 않은 것처럼 보인다.

#### 1-6-4. 부모요소에 float을 넣는 경우

이 방법은 float을 float으로 해결하는 방법으로 float된 요소를 그룹핑해 또 좌, 우측으로 float을 이용해야할 경우 사용한다.

이경우 float된 부모요소는 그 부모요소가 높이를 인식하지 못하므로 clear하는 방법을 필요로한다. (다음 형제요소에 clear:both를 준다든지) 또한 부모요소가 자식요소의 너비만큼 줄어든다.

#### 1-6-5. 가상선택자 ::after에 clear를 주는 방법

**::before, ::after**
+ CSS2: :before, :after (ie9까지 대응)
+ CSS3: ::before, ::after

인라인 상자가 가짜로 만들어진다. `content`로 값을 추가시킬 수도 있다. `content`가 반드시 있어야 가짜 요소가 만들어진다.

```css
.main::after {
  content: ''; /*  null, 가끔 여기에 공백을 넣는 사람도 있음 */
  clear: both;
  /* 인라인 요소는 마진값을 줄 수 없으므로 */
  display: block;
}
```
`clear: both`로 강제 마진을 주려면 디스플레이가 블록이어야 한다.

공통으로 사용되는 이 css를 모듈화 시켜서 재사용 가능하도록 하는 게 좋다.
```css
.clearfix:after {
  content: '';
  clear: both;
  display: block;  
}
```

```html
<main class="main clearfix">
  <section class="recommend-book">추천 서적</section>
```

### 1-7. 기타

#### 1-7-1. wai-aria의 role(역할 모델)

전맹시각자들이 콘텐츠를 탐색할 때 div로만 되어 있으면 시행착오를 많이 거쳐야 그 콘텐츠를 이해할 수 있다.

랜드마크라해서 기계가 이해할 수 있는 표시를 해주는것  
스크린리더는 랜드마크 단위로 탐색가능  
role : banner, navigation, main, article, content info

이러한 방법은 시각자들의 사용성을 높게한다.

가능한 HTML5 시멘틱 태그를 쓰는 네이티브 방식이 더 낫다.  
그러나 이미 현업에서 div로 짜여진 소스를 유지보수해야한다면 태그 수정에따른 위험을 고려해서 웹접근성을 위해 aria 역할모델인 `role=""`을 추가해주자

#### 1-7-2. HTML5 콘텐츠 모델을 고려하자

현업에서 개발자들이 실수하는 것 중에 ul 아래에 빈 div를 넣는 경우가 있다.

> Error: Element div not allowed as child of element ul in this context. (Suppressing further errors from this subtree.)

```html
<ul class="member">
  <div class="box"></div>
  <li></li>
</ul>
```

HTML5는 블록, 인라인 모델로의 구분은 없어졌지만 콘텐츠 모델 단위로 해석한다. 
`ul` 요소는 자식요소로 `li`요소 외에는 받을 수 없다.  
우선 마크업을 validation을 돌리고 에러가 난다면, 
콘텐츠 모델의 허용하는 자식요소에 대한 규칙 같은 것을 확인하자.

`a` 해당 텍스트가 하이퍼링크임을 의미, 인터렉티브 모델인데 `href` 속성이 없다면 인터렉티브 모델이 아니다.


### 1-2. HTML 구조 설계

구조와 디자인 사이의 간극이 있을때 고민해서 최적의 결과를 도출해야된다. 
콘텐츠 중심으로 논리적인 마크업이 필요하다. 그러므로 테이블로 구성하는 마크업은 지양한다. 

* 콘텐츠 중심(논리적인 마크업) -> 시맨틱마크업 -> 네이밍  

#### 실습 헤더 작업

모바일 퍼스트로 고려하라는 말은 논리적인 흐름을 해치지 않을때이다.  
서비스의 성격에 따라 논리 흐름은 다를 수 있다. (가입을 먼저 유도해야 한다든가, 검색을 우선한다든가.) 서비스에 대한 고민을 해야한다.

##### 로고 작업

이미지로 마크업할 지, 텍스트로 할 지 고민해야한다. 텍스트로 해서 백그라운드로 이미지를 제공하고 텍스트는 숨길건지 개발방향을 정한다.

ir 기법, 또는 wai-aria 기법을 이용해 대체 텍스트 혹은 정보를 제공해준다. (ex: aria-label="대체 텍스트명")

🔖 [responsive logo](http://responsivelogos.co.uk/) - 텍스트없이 백그라운드만 넣은 로고는 웹접근성 관점에서는 좋지 않다. 

모바일은 디스플레이 성능이 굉장히 좋아졌다. 레티나 디스플레이의 경우 일반 해상도의 2 배이다. 데스크탑에 맞춰 제공한 이미지가 레티나 에서는 흐릿해보이는데 이는 그 이미지를 2 배 늘려서 보여주기 때문이다.  
아이폰과 최근 갤럭시는 3, 4 배까지 늘어났으며 그만큼 큰 이미지를 제공하거나 벡터 이미지(svg)를 사용하는 것이 좋다. 이미지 사용을 줄이는 것을 권장한다.

만약 텍스트로 제공한다면 SEO 관점에서 검색 노출에도 좋다.

```html
<h1 class="logo">
  <a href="">
    <img src="logo.png" alt="Web Cafe">
  </a>
</h1>
```

img 의 alt 에 이미지와 동등한 내용을 넣어준다.  
예) Web Cafe (o), 로고 (x)
웹접근성 관점에서 WebCafe 보단 Web Cafe 라고 띄어쓰기를 지켜줘야 스크린리더가 적절히 읽을 수 있다.

※ 웹 접근성 평가 :
정성적인 평가(사람이 일일이 체크), 정량적인 평가(기계적으로 평가)
QA 테스트할때 다양한 레포팅 툴 중에 openWAX 도 사용된다.

```html
<h1 class="logo"><!-- 브랜딩이 가장 중요한 대제목이라고 생각한다면 -->
  <a href=""><!-- 홈으로의 연결이 필요하다면 -->
    <img>
  </a>
</h1>
<ul class="member"><!-- 순서가 중요하지 않은 리스트라 ul을 쓴다 -->
  <li><a href="">로그인</a></li> <!-- 독립된 링크라고 생각해서 li로 감싸줬다. -->
  <li><a href="">로그인</a></li>
  <li><a href="">로그인</a></li>
</ul>
<form action=""><!-- action이 필수적인 속성임 인풋 값들이 action으로 넘겨짐-->
  <fieldset><!-- 연관성 있는 컨트롤들을 묶어준다 -->
  <!-- 필수 정보, 선택적 정보의 그룹핑을 나누고 싶을때라거나 -->
    <legend>검색</legend>
    <label for="search">검색어</label>
    <input type="search" placeholder="" id="search">
    <button class="btn-search">검색</button>
  </fieldset>
</form>
```

### 1.4. 포지션 

모든 요소는 움직일 수 없는 정적(`static`)인 상태가 기본이다.(`position: static`) - 어떤 요소에 고정적으로 붙어있는 상태

position의 값(static default)  
relative, absolute, fix, sticky(추가됨)
 
원하는 것에 자유롭게 배치가 가능하나 노가다이다.
position: static((기본)

position: absolute
레이어화
컨텐츠 크기만큼 넓이가 수정된다.(블록 상자가 전체를 차지하는 경우는 일반적인 흐름일 경우다.)
float되는 순간 block상자처럼 바뀐다. position:absolute도 마찬가지 블록화.
absolute를 넣을경우 띄워졌지만 자신의 위치는 기억하고 있음 하지만 위치값을 넣으면 static인 상위 요소를 계속 무시하면서 position값이 static이 아닌 상위요소 기준으로 삼는다.

position:relative;  

일반적인 흐름을 유지하면서 absolute의 기준으로 만들때 사용. 
자기자신의 위치를 기준으로 움직인다. 레이어화되지만(다른 요소와 겹쳐질 수 있다.) 일반적인 흐름을 유지한다. 

> 이미지가 공백을 가지지 않게 커팅하자 그래야 이러한 위치를 조정하기 쉽다.

width 가 auto일때 left, right 값을 둘다 넣으면 그 기준으로 width가 늘어난다.

> center position트릭
이런 트릭이 나올 수 있는 원인이 뭘까 생각해보자.

transform 속성에 translateY()라 해서 위치변경 값이 있음
```css
.logo {
  background-color: blue;
  margin: 0;
  position: absolute;
  left: 50px;
  top: 50%;
  /* 익스 9에서는 쓸 수 없다. */
  /* transform: translateY(-50%) */
  margin-top: -20px; /* 단 콘텐츠가 고정된 사이즈일 경우 */
  /* position: absolut
  /* right:50px */
  /* padding: 1em; */
  /* float: left; */
}
```

position: fixed;  ie6에서는 이거를 스크립트로 구현해야했다. 스크롤내릴때마다 위치를 조정;;

해외 좋은 서비스들 많이 찾아보자.

position: sticky 

일반적인 흐름을 유지하면서 스티커처럼 따라붙는다

*** polyfill: 브라우저가 지원하지 않는 기술을 지원하기 위한 대안
sticky에서 polyfill보다 another polyfill이 더 안정적인듯


##### 네비게이션 



## 2. Today I fonund out

CSS3 애니메이션이나 트랜스폼등 처리하면서 그래도 다양하게 사용하고 있다고 생각했는데 표준화 된 방대한 모듈과 아직 개발되고 있는 많은 모듈들을 보니 배울게 굉장히 많은 것 같다.

marign: 0 auto 는 가운데 정렬을 위한 기술 정도로 생각하고 있었다 auto 란 것이 요소를 가운데로 보내준다고 생각했지 나머지 영역을 차지하고 있기 때문이라고는 생각하지 않고 있었다.  
HTML5 의 기술도 모르거나 사용하지 않았던게 굉장히 많다. 일할때 좀 더 부지런히 공부하고 사용해 볼 걸 생각도 들고 IE8 혹은 IE7 까지는 대응해야하는 프로젝트라 써보지 못했던 기술들을 보면 협업 환경(웹에이전시)과 웹 개발의 발전 간의 차이가 많이 아쉽다.

flex 같은 경우는 폴리필과 같이 사용했는데도 깨져서 다 걷어냈던 적도 있었다. 그 프로젝트 같은 경우는 해외에서 먼저 디자인이 나온 사이트였고 해외 사이트의 디자인 가이드에 맞춰 국내 사이트를 만들어야 했는데 해외 사이트에서는 쓰고 있는 방식을 국내 환경에 맞추려니 쓰지 못한 게 많았다. flex 가 제일 대표적이다.  
그런 환경이 아쉽기도 하고 그 환경에 순응하면서 다른 대안을 찾아보지 않았던 나도 많이 반성한다.

## 3. 오늘 읽은 자료 (혹은 참고할 링크)

- [box sizing](https://css-tricks.com/box-sizing/) : bos-sizing 에 대한 CSS Tricks 문서
- [visual formatting model](https://goo.gl/VEQyxY) : 문서를 처리하거나 시각 매체에서 나타내는데 사용되는 알고리즘인 비주얼 서식 모델에 대한 MDN 문서
