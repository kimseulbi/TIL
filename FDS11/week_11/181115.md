# 11/15 (목)

## 1. Today I learend

> 개인학습

## 1.1. 예외 처리

예기치 못한 에러가 발생했을 때, 이로부터 코드의실행 흐름을 복구할 수 있는 기능이 내장, 예외 처리라고 합니다.

동기식 코드에서의 예외처리
동기적 - 순차적으로 일을 스스로 끝내 나가는 방식
비동기적 - 해야 할 일을 위임하고 기다리는 방식
프로그래머의 실수, 네트워크 에러와 같이 코드와 무관한 이유 에러

코드 실행 중에 에러가 발생하면, 코드의 실행이 중단되어 그 시점에 실행 중이었던 작업을 완료할 수 없게 됩니다.
자바스크립트는 이로부터 코드의 실행 흐름을 원상복구할 수 있는 기능 제공

## 1.2. React

### 컴포넌트와 props

컴포넌트를 통해 UI를 독립적이고 재사용 가능한 부분으로 분리하고, 각 부분을 독립적

개념상 컴포넌트는 자바스크립트 함수와 비슷, "Props"이라 불리는 임의의 입력을 받아들이고, 화면에 무엇이 표시되어야 하는지 를 서술하는 React 요소를 반환합니다.

#### 함수형 및 클래스 컴포넌트

컴포넌트를 정의하는 가장 간단한 방법은 자바스크립트 함수를 작성하는 것입니다.

```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

이 함수는 유효한 React컴포넌트로 "Props" 객체 인수를 받고 React요소를 반환. 이런한 컴포넌트는 말 그대로 자바스크립트 함수이기 때문에 "함수형 컴포넌트"라고 부릅니다.

컴포넌트를 정의하기위해 class를 사용

```js
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

#### 컴포넌트 렌더링

React가 사용자 정의 컴포넌트를 나타내는 요소를 처리할 때는, jsx 어트리뷰트를 하나의 객체를 통해 컴포넌트로 전달, 이 객체를 "Props"

```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

const element = <Welcome name="Sara" />;
ReactDOM.render(element, document.getElementById("root"));
```

```
컴포넌트 이름은 항상 대문자로 시작
```

#### 컴포넌트 조립

컴포넌트의 출력에서 다른 컴포넌트를 가져와 사용. 모든 세부 레벨에서 동일한 컴포넌트 추상화를 사용. React 앱에서 버튼, 폼, 다이얼로드, 스크린 같은 것들은 모두 일반적으로 컴포넌트로 표현

#### 컴포넌트 추출

컴포넌트를 추출하는 건 처음에는 쓸데없는 일처럼 보일 수 있지만, 재사용 가능한 컴포넌트 팔레트를 사용하면 큰 앱에서 그 진가를 발휘합니다. 적당한 기준을 잡아보자면 , UI의 일부분이 여러번 사용되거나, 자체적으로 충분히 복잡하다면 그것들은 재사용 가능한 컴포넌트가 도리 좋은 후보

#### Props는 읽기전용

컴포넌트를 함수나 클래스 중 어떤걸로 선언했건, 자기 자신의 props를 수정할 수 없습니다.

```js
function sum(a, b) {
  return a + b;
}
```
위와 같은 함수는 입력을 변경하려 하지 않고, 동일한 입력에 대한 항상 동일한 결과를 반환하기 때문에 순수함수라고 불립니다.

위와 반대로, 이 함수는 입력을 변경하기 떼문에 순수하지 않습니다.

```js
function withdraw(account, amount) {
  account.total -= amount;
}
```
React는 매우 유연하지만 한가지 엄격한 규칙을 갖고 있습니다. 

**모든 React 컴포넌트는 Props에 대해서는 순수 함수처럼 동작해야합니다.**



### State와 라이프사이클

State는 Props와 비슷하지만 바깥으로 공개되지않으며, 컴포넌트에 의해 완전히 제어됩니다.

클래스로 정의한 컴포넌트에는 몇가지 추가 기능이 있습니다. 지역적인 State가 그러한 기능으로, 클래스에서만 사용 가능합니다.

함수형 컴포넌트를 함수 대신 클래스로 정의 하면 이를 통해 지역적인 State나 라이프사이클 훅 같은 추가 기능을 사용할 수 있습니다.

많은 컴포넌트를 가진 어플리케이션에서, 컴포넌트가 제거될 때 사용중이던 자원을 돌려놓는 작업은 아주 중요한 일입니다.

DOM에 최초로 렌더링 될떄 "mounting"
DOM에 삭제되었을 때 "unmounting"

컴포넌트가 마운트 되거나 언마운트 되는 시점에 코드를 실행하기 위해, 컴포넌트 클래스에 특별한 메서드를 선언할 수 있습니다.

`componentDidMount()` 컴포넌트 출력이 DOM에 렌더링 된 이후 동작, 컴포넌트 생성 후

`componentWillUnmount()` 라이프사이클 훅에서 종료, 컴포넌트 제거

State 바르게 사용하기

1. State를 직접 수정 하지 마세요.

- setState()사용
- this.state를 할당할 수 있는 유일한 장소는 생성자 함수 내부

1. State업데이트는 비동기일 수 있습니다.
1. State업데트는 병합

데이터는 아래로 흐릅니다.

부모 컴포넌트나 자식 컴포넌트는 특정 컴포넌트의 state 유무를 알 수 없으며, 해당 컴포넌트가 함수나 클래스로 선언되었는지 알 수 없습니다.

state가 '지역적이다' 혹은 '캽슐화도었다'고 하는 이유, state를 지정해 준 컴포넌트 와의 다른 컴포넌트에서는 state에 접근할 수 없습니다.

컴포넌트는 자신의 state를 props로서 자식 컴포넌트에 내려줄 수 있습니다.

```js
<h2>It is {this.state.date.toLocaleTimeString()}.</h2>
```

사용자 정의 컴포넌트에서 마찬가지로 동작합니다.

```js
<FormattedDate date={this.state.date} />
```

이런 데이터 흐름을 보통 "하향식" 혹은 "단방향" 데이터 흐름이라고 합니다. 모든 state는 항상 특정 컴포넌트를 가지며, 해당 state에서 파생된 모든 데이터와 UI는 트리의 "아래"에 있는 컴포너트에만 영향을 미칩니다.

컴포넌트 트리를 props의 폭포라고 상상해보면, 각 컴포넌트의 상태는 임의의 지점에서 추가되는 물과 비슷하고 또한 아래로 흐릅니다.

**문제 풀기 위해서 알아둘것**

## 1.3. map

map 메소드는 배열의 각 요소에 함수를 적용해서, 그 반환값을 요소로 갖는 새로운 배열을 만든다.
`forEach`와 비슷해 보이지만, 새로운 배열을 만든다는 점이 다름.

map 역시 인수로 들어온 함수를 호출할 때 세게의 인수를 넘긴다.

```js
const arr = [1, 2, 3, 4, 5];

// `arr`의 각 요소를 제곱한 값으로 새 배열을 만듭니다.
const newArr = arr.map(item => item ** 2);
console.log(newArr); // [1, 4, 9, 16, 25]

arr.map((item, index, array) => {
  return item * index;
});
```
