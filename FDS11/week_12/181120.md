# 11/19 (월)

## 1. Today I learend

> React

## 1.1 React

### 제어되지 않는 컴포넌트

폼을 구현할 때에는 웬만하면 제어되는 컴포넌트를 사용하시기를 권합니다. 제어되는 컴포넌트를 사용하면, 폼 데이터가 React에 의해 적절히 제어될 수 있기 때문입니다. 반면 제어되지 않는 컴포넌트를 사용하면, 폼 데이터는 DOM의 자체 기능에 의해 제어됩니다.

실무에서 사용합니다. 개인적으로 많이 사용 합니다.

제어되지 않는 컴포넌트를 만들 때에는 상태 업데이트를 위해 이벤트 핸들러를 작성할 필요가 없습니다. 대신 ref를 사용해서 폼 데이터를 DOM으로부터 가져올 수 있습니다.

제어되지 않는 컴포넌트는 진리의 원천을 DOM에 두기 때문에, React를 사용한 코드와 사용하지 않은 코드를 통합하는 작업을 좀 더 쉽게 만들어줄 수 있습니다. 그리고 코드의 양이 상대적으로 적습니다. 좀 지저분하지만 빠른 해결책을 원한다면 제어되지 않는 컴포넌트를 사용하세요. 그렇지 않다면, 제어되는 컴포넌트를 사용하세요.

아직 어떤 상황에서 무엇을 써야하는지 명확히 감이 오지 않는다면, 제어되는 input과 제어되지 않는 input에 대한 글이 도움이 될 수 있습니다.

#### 기본값 지정하기

React의 렌더링 라이프사이클에서는, 폼 엘리먼트에 지정된 value 어트리뷰트가 DOM의 값을 덮어쓸 것입니다. 반면 제어되지 않는 컴포넌트를 사용할 때, DOM의 상태변화는 제어되지 않는 상태로 두면서도 초기값을 지정해주어야 하는 경우가 있습니다. 이런 경우를 위해, defaultValue 어트리뷰트를 value 대신 사용할 수 있습니다.

html에 value를 사용하면 기본값을 넣어주는 값이나 react에서는 value값을 넣으면 기본값외에 다른 입력값을 넣을 없습니다. 하지만 defaultValue를 사용한다면 html vaule값가 동일한 기능을 합니다.

비슷하게`<input type="checkbox"`>와 `<input type="radio">`엘리먼트는 defaultChecked 어트리뷰트를, `<select>`와 `<textarea>`는 defaultValue 어트리뷰트를 지원합니다.

### 성능 최적화

React는 내부적으로 UI 업데이트를 위해 필요한 값 비싼 DOM 연산 개수를 최소화하기 위해 몇가지 영리한 기술을 사용합니다. 많은 어플리케이션에서 React를 사용하면 성능 최적화를 위해 많은 작업을 하지 않더라도 빠른 유저 인터페이스로 이어질 것입니다. 그럼에도 불구하고 React 어플리케이션의 속도를 높이는 몇가지 방법이 있습니다

리액트는 화면을 다시 그릴때 마다 render 메소드를 다시 다 실행해 봅니다.
상태로 부터 어떤것이 바꿨는지 알아보기 위해서 recder메소드를 다 실행해 봅니다.
매번 계산하는 과정떄문에 성능이 저하될수 밖에 없다.

props, state는 객체이다.
props, state 정보를 통해서 화면을 그리는 react
props, state 속성이 변하지 않았다면 화면을 다시 그리지 않겠죠?

//최적화적용 하는 Component

불변성 -> 내용이 변경 되었을떄 참조도 변경이 되었다면 그것이 불변이다.
불변인것처럼 코딩을 했다면 React는 참조만 확인하여 화면을 빠르게 그린다.
나중을 위해서 불변인것처럼 작업을 해야합니다.

PureComponent Vs Component

// 깊은 복사시에도 PureComponent를 사용할수 있습니다.
// 제일 비용이 저렴하게 있는것이 불변성

[immutable](https://facebook.github.io/immutable-js/)
// immutable
// 불변의 값을 편하게 사용 할수있습니다.
// 내장된 객체와 내장배열을 사용수 없습니다.

[immer](https://github.com/mweststrate/immer)
// immer
// 불변의 값을 편하게 사용 할수있습니다.
// 내장된 객체와 내장배열을 사용할수있음.
// push를 사용 하면 원래는 불변성을 사용하면 안되는데 불변으로 만들수 있으며 깊은 복사도 가능합니다.

#### 비교조정 (Reconciliation) 피하기

React는 렌더링된 UI의 내부 표현을 만들고 관리합니다. 여기에는 컴포넌트가 반환하는 React 요소도 포함됩니다. 이 표현은 React가 자바스크립트 노드 작업보다 느릴 수 있으므로 필요에 따라 DOM 노드를 만들고 기존 노드에 접근하지 못하게합니다. 때로는 “가상 DOM (virtual DOM)“이라고 하지만 React Native에서도 같은 방식으로 동작합니다.

컴포넌트의 props나 state 변경되면 React는 새로 반환된 요소를 이전에 렌더링된 것과 비교하여 실제 DOM 업데이트가 필요한지 여부를 결정합니다. 둘이 동일하지 않다면 React는 DOM을 업데이트합니다.

일부 케이스에서는 컴포넌트에서 다시 렌더링하는 프로세스가 시작되기 전에 트리거되는 라이프사이클 함수 shouldComponentUpdate 를 재정의하여 이러한 모든 것을 가속할 수 있습니다. 이 함수의 기본 구현체는 true 를 반환하고 React는 업데이트를 수행합니다.

```js
//PureComponent가 내장하고 있는 메소드
shouldComponentUpdate(nextProps, nextState) {
  return true;
}
```

일부 상황에서 컴포넌트를 업데이트할 필요가 없는 경우 shouldComponentUpdate 에서 false 를 반환하여 이 컴포넌트 및 하위에서 호출하는 render() 를 포함한 전체 렌더링 프로세스를 스킵할 수 있습니다.

> 화면을 느려졌을때 사용 하는 shouldComponentUpdate, PureComponent가

https://www.youtube.com/watch?v=7jY1ABmuxr8

### 비교조정 (Reconciliation)

React는 선언적 API를 제공하기 때문에 갱신이 될 때에 정확히 무엇이 바뀌었는지를 걱정할 필요가 없습니다. 이는 어플리케이션 작성을 더욱 쉽게 만들어주지만, React 내부에서 어떤 일이 일어나고 있는지는 명확히 눈에 보이지 않습니다. 이 글에서는 우리가 React의 “비교” 알고리즘을 만들 때 어떤 선택을 했는지를 소개합니다. 이 비교 알고리즘 덕분에 컴포넌트의 갱신이 예측 가능해지면서도 고성능 앱이라고 불러도 손색 없을 만큼 충분히 빠른 앱을 만들 수 있습니다.

#### 동기

여러분이 React를 사용하면서, ’render() 함수는 React 엘리먼트의 트리를 만들어주는 것이다’라고 생각하게 되는 시점이 있을 것입니다. 다음 번의 state 혹은 props 변경 시점에, render() 함수는 다르게 생긴 React 엘리먼트 트리를 반환할 것입니다. 이 때 React 입장에서는 방금 만들어진 트리에 부합하도록, 기존 UI를 효율적으로 갱신하는 방법을 알아내야 할 필요가 있습니다.

이러한 알고리즘 문제, 즉 하나의 트리를 다른 트리로 변형시키는 가장 작은 조작 방식을 알아내는 문제에 대한 몇 가지 일반적인 해결책이 있습니다. 하지만, 최첨단의 알고리즘도 n개의 엘리먼트를 갖는 트리에 대해 O(n3)의 복잡도를 가집니다.

만약 이 알고리즘을 그대로 React에 적용하면, 1000개의 엘리먼트를 표시하는 작업은 10억 번의 비교 연산을 필요로 하게 됩니다. 이는 너무 비싼 연산입니다. 대신, React는 두 가지 가정에 기반해 O(n) 복잡도의 휴리스틱 알고리즘을 구현했습니다:

다른 타입을 가진 두 엘리먼트는 다른 트리를 만들어 낼 것이다.
개발자가 제공한 key prop을 이용해, 여러 번의 렌더링 속에서도 변경되지 말아야 할 자식 엘리먼트가 무엇인지를 알아낼 수 있을 것이다.
실제로 거의 모든 사용 사례에 대해 이 가정들이 들어맞습니다.

하나는 엘리먼트, 하나는 key를 비교 하는데 둘개중에 하나가 달라지면 비교 하지 않고 다시 그린다.

#### 다른 타입의 엘리먼트인 경우

루트 엘리먼트들의 타입이 다르다면, React는 이전 트리를 버리고 트리를 완전히 새로 구축합니다. `<a>`에서 `<img>`로, 혹은 <Article>에서 <Comment>로, 혹은 <Button> 에서 `<div>`로 바뀌는 것 모두가 트리 전체를 새로 구축하는 결과를 낳습니다.

트리를 버릴 때, 이전 DOM 노드들은 모두 파괴됩니다. 또한 컴포넌트 인스턴스의 componentWillUnmount() 라이프 사이클 훅이 실행됩니다. 새 트리가 구축될 때, 새 DOM 노드들이 DOM 안에 삽입됩니다. 그에 따라 컴포넌트 인스턴스의 componentWillMount() 훅이 실행되고, 그 다음 componentDidMount() 훅이 실행됩니다. 이전 트리에 연결되어 있던 모든 state가 유실됩니다.

엘리먼트 타입이 바뀌면 이전 엘리먼트 타입에 모든것이 지워집니다.

```js
// 위에 있는 컴포넌트가 바뀌면 상태, 자식 요소도 제거됩니다.
<div>
  <Counter />
</div>

<span>
  <Counter />
</span>
```

전 Counter는 파괴되고 새 것이 다시 마운트될 것입니다.

#### 같은 타입의 DOM 엘리먼트인 경우

같은 타입의 두 React DOM 엘리먼터를 비교할 때, React는 양쪽의 속성을 살펴본 뒤 같은 것들은 유지시키고 변경된 속성만을 갱신합니다. 예를 들어:

```js
<div className="before" title="stuff" />

<div className="after" title="stuff" />
```

두 요소를 비교하여 React는 DOM 노드에서 className 만 수정되고있다는 사실을 알게됩니다.

#### 같은 타입의 컴포넌트 엘리먼트인 경우
컴포넌트의 내용이 갱신될 때, 해당 인스턴스는 유지되고 그에 따라 state가 여러 렌더링에 걸쳐 유지될 수 있습니다. React는 새로운 엘리먼트의 내용을 반영하기 위해 컴포넌트 인스턴스의 props를 갱신합니다. 또한 그 인스턴스의 componentWillReceiveProps()와 componentWillUpdate()를 호출합니다.

다음으로, render() 메소드가 호출되고 비교 알고리즘은 이전 트리와 새로운 트리를 재귀적으로 처리합니다.(재귀함수 참고)

props바뀔뿐 state날아가지 않는다. 

#### 키
React는 이 문제를 해결하기 위한 방법으로 key 속성을 지원하고 있습니다. 만약 자식이 키를 갖고 있다면, React는 그 키를 이용해 원래 트리의 자식과 새 트리의 자식 간이 일치하는 지를 결정할 수 있습니다. 예를 들어, 우리의 비효율적인 예제에 key를 추가하면 트리의 변환을 효율적으로 수행할 수 있습니다.

만약 이러한 경우에 해당하지 않는다면, 여러분의 데이터 모델에 ID라는 새로운 속성을 추가하거나 혹은 데이터의 일부에 해시를 적용해서 키를 생성할 수 있습니다. 그 키는 오로지 형제 사이에서만 유일하면 되고, 전역에서 유일할 필요는 없습니다.

같은 자료형은 같은 키를 사용 해야합니다. 그러지 않으면 다른 자료로 인식합니다. 

상태를 강제로 초기화할때도 키를 사용합나다.

https://codesandbox.io/s/7mxww787j6


## 2. Today I fonund out

## 3. 오늘 읽은 자료 (혹은 참고할 링크)
[Create React App](https://github.com/facebook/create-react-app)