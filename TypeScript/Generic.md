## Generic 제너릭

제너릭은 어떤한 클래스 혹은 함수에서 사용할 타입을 그 함수나 클래스를 사용할 때 결정하는 프로그래밍 기법을 말한다.

TypeScript도 마찬가지로 정적 타입언어이기 때문에, 기본적으로 타입을 정의한 함수 혹은 클래스는 모두 다른 타입에 재사용할 수없다.

사용자는 컴포넌트를 사용할 때 자신만의 타입을 사용할 수 있습니다.

any를 사용하는 것은 분명히 한수가 `arg`에 대한 모든 타입을 전달 받을 수 있게 되지만 실제로 함수가 반환할 때 그타입이 무엇이었는지 대한 정보를 잃어버립니다.
만약 숫자를 인수로 전달하면 어떤 타입이든 반환될 수 있다는 것을 알수 있습니다.

대신 어떤 타입이 반환될 것인지를 나타내는 데 사용할 수 있는 방식으로 인수 타입을 전하는 방법이 필요합니다.
여기서 값이 아닌 타입을 처리하는 특별한 종류의 변수인 타입변수을 사용할 것입니다.

```js
function identity<T>(arg: T): T {
  return arg;
}
```

identity 함수에 타입변수 T 를 추가했습니다.
이 T는 함수 사용자가 제공한 타입(예: number)을 캡처하여 나중에 해당 정보를 사용할 수 있도록 합니다. 또한 T를 다시 반환 타입으로 사용합니다. 자세히 보면 인수와 반환 타입에 동일한 타입이 사용되는것을 볼 수 있습니다.
이를 통해 함수의 안과 밖에서 타입에 대한 정보를 넘길 수있습니다.

이러한 모습의 identity함수는 다양한 타입을 처리할 수 있기 때문에 일반적이라고 할 수 있습니다.
`any`를 사용하는 것과는 달리 인수와 반환 타입에 숫자를 사용하는 처음의 identity 함수와 동일합니다. (즉, 어떠한 정보도 잃어버리지 않습니다.)

제네릭 identity 함수를 만든 후 두 가지 방법 중 하나로 호출할 수 있습니다.
첫번째 방법은 타입 인수를 포함한 모든 인수를 함수에 전달하는 것입니다.

```js
let output = identity < string > "myString"; // 반환 타입은 'string' 입니다.
```

여기서는 함수 호출에 대한 인수 중 하나인 T를 string으로 명시적으로 정했으며 인수에는 ()를 사용하는 것과 달리 <> 를 사용했습니다.

두번째 방법은 더 일반적인 방법이기도 합니다.
여기서는 타입 인수 추론를 사용합니다.
즉 함수에 전달하는 인수 타입에 따라 컴파일러가 자동으로 T 값을 설정합니다.

```js
let output = identity("myString"); // 반환 타입은 'string' 입니다.
```
